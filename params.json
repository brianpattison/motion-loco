{"name":"Motion-Loco","tagline":"Library for RubyMotion that includes Ember.js inspired bindings, computed properties, and observers.","body":"## A complete rewrite is coming soon!\r\n\r\nHere's a peak at the direction \r\nI'm hoping to go for version 0.3.0:\r\n\r\n```ruby\r\nclass User < Loco::Model\r\n  # Properties with types and defaults\r\n  property :first_name, :string\r\n  property :last_name, :string\r\n  property :login_count, :integer, default: 0\r\n  \r\n  # Computed properties\r\n  property :full_name, -> {|user|\r\n    \"#{user.get(:first_name)} #{user.get(:last_name)}\"\r\n  }.property(:first_name, :last_name)\r\n  \r\n  # Associations\r\n  belongs_to :group\r\n  has_many :posts, class_name: BlogPost\r\n  \r\n  # Computed properties will be able to \r\n  # observe a chain of properties\r\n  property :post_count, -> {|user|\r\n    user.posts.length\r\n  }.property(\"posts.length\")\r\n  \r\n  # Computed properties based on changes made\r\n  # to records inside a Loco::RecordArray\r\n  property :published_posts, -> {|user|\r\n    user.posts.select{|post|\r\n      post.get(:is_published)\r\n    }\r\n  }.property(\"posts.@each.is_published\")\r\nend\r\n\r\n# Everything will use #get and #set so that computed properties\r\n# can be cached and calculated only when required\r\n@user = User.new(first_name: \"Brian\")\r\n@user.get(:first_name)  # \"Brian\"\r\n@user.get(:login_count) # 0\r\n\r\n# Underscore and camelized properties work the same\r\n@user.set(:lastName, \"Pattison\") # \"Pattison\"\r\n\r\n# Chained property getters/setters\r\n@user.get('group.name') # \"The Awesome Group\"\r\n@user.set('group.name', \"The Humble Group\")\r\n\r\n# Properties won't be KVO compliant, but it will\r\n# be easy to create observers for any observable object.\r\n@user.observe(:login_count, -> {|user|\r\n  new_count = user.get(:login_count)\r\n  user.remove_observer(:login_count)\r\n})\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}